/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * DOCUMENTATION
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * Contact: contact-email@something.io
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
// import * as portableFetch from "portable-fetch";
import { Configuration } from './configuration';
const portableFetch = {};

const BASE_PATH = 'http://localhost:1337'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface Body
 */
export interface Body {
  /**
   *
   * @type {string}
   * @memberof Body
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface Body1
 */
export interface Body1 {
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface Body2
 */
export interface Body2 {
  /**
   *
   * @type {string}
   * @memberof Body2
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface Body3
 */
export interface Body3 {
  /**
   *
   * @type {string}
   * @memberof Body3
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface Body4
 */
export interface Body4 {
  /**
   *
   * @type {string}
   * @memberof Body4
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface Body5
 */
export interface Body5 {
  /**
   *
   * @type {string}
   * @memberof Body5
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface Body6
 */
export interface Body6 {
  /**
   *
   * @type {string}
   * @memberof Body6
   */
  foo?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse200
   */
  count?: number;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 *
 * @export
 * @interface NewPosts
 */
export interface NewPosts {
  /**
   *
   * @type {string}
   * @memberof NewPosts
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof NewPosts
   */
  content?: string;
  /**
   *
   * @type {Date}
   * @memberof NewPosts
   */
  publishedAt?: Date;
  /**
   *
   * @type {string}
   * @memberof NewPosts
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof NewPosts
   */
  updatedBy?: string;
}
/**
 *
 * @export
 * @interface NewUsersPermissionsRole
 */
export interface NewUsersPermissionsRole {
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsRole
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsRole
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsRole
   */
  type?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof NewUsersPermissionsRole
   */
  permissions?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof NewUsersPermissionsRole
   */
  users?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsRole
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsRole
   */
  updatedBy?: string;
}
/**
 *
 * @export
 * @interface NewUsersPermissionsUser
 */
export interface NewUsersPermissionsUser {
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  provider?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  resetPasswordToken?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  confirmationToken?: string;
  /**
   *
   * @type {boolean}
   * @memberof NewUsersPermissionsUser
   */
  confirmed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof NewUsersPermissionsUser
   */
  blocked?: boolean;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof NewUsersPermissionsUser
   */
  updatedBy?: string;
}
/**
 *
 * @export
 * @interface Posts
 */
export interface Posts {
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  content?: string;
  /**
   *
   * @type {Date}
   * @memberof Posts
   */
  publishedAt?: Date;
}
/**
 *
 * @export
 * @interface UsersPermissionsRole
 */
export interface UsersPermissionsRole {
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRole
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRole
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRole
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRole
   */
  type?: string;
  /**
   *
   * @type {Array<UsersPermissionsRolePermissions>}
   * @memberof UsersPermissionsRole
   */
  permissions?: Array<UsersPermissionsRolePermissions>;
  /**
   *
   * @type {Array<UsersPermissionsRoleUsers>}
   * @memberof UsersPermissionsRole
   */
  users?: Array<UsersPermissionsRoleUsers>;
}
/**
 *
 * @export
 * @interface UsersPermissionsRolePermissions
 */
export interface UsersPermissionsRolePermissions {
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  controller: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  action: string;
  /**
   *
   * @type {boolean}
   * @memberof UsersPermissionsRolePermissions
   */
  enabled: boolean;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  policy?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRolePermissions
   */
  updatedBy?: string;
}
/**
 *
 * @export
 * @interface UsersPermissionsRoleUsers
 */
export interface UsersPermissionsRoleUsers {
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  provider?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  resetPasswordToken?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  confirmationToken?: string;
  /**
   *
   * @type {boolean}
   * @memberof UsersPermissionsRoleUsers
   */
  confirmed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UsersPermissionsRoleUsers
   */
  blocked?: boolean;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsRoleUsers
   */
  updatedBy?: string;
}
/**
 *
 * @export
 * @interface UsersPermissionsUser
 */
export interface UsersPermissionsUser {
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUser
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUser
   */
  provider?: string;
  /**
   *
   * @type {boolean}
   * @memberof UsersPermissionsUser
   */
  confirmed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UsersPermissionsUser
   */
  blocked?: boolean;
  /**
   *
   * @type {UsersPermissionsUserRole}
   * @memberof UsersPermissionsUser
   */
  role?: UsersPermissionsUserRole;
}
/**
 *
 * @export
 * @interface UsersPermissionsUserRole
 */
export interface UsersPermissionsUserRole {
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUserRole
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUserRole
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUserRole
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUserRole
   */
  type?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UsersPermissionsUserRole
   */
  permissions?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UsersPermissionsUserRole
   */
  users?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUserRole
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof UsersPermissionsUserRole
   */
  updatedBy?: string;
}
/**
 * EmailEmailApi - fetch parameter creator
 * @export
 */
export const EmailEmailApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Send an email
     * @param {Body} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailPost(body: Body, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling emailPost.'
        );
      }
      const localVarPath = `/email/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the email settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailSettingsGet(options: any = {}): FetchArgs {
      const localVarPath = `/email/settings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send an test email
     * @param {Body1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTestPost(body: Body1, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling emailTestPost.'
        );
      }
      const localVarPath = `/email/test`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body1' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EmailEmailApi - functional programming interface
 * @export
 */
export const EmailEmailApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Send an email
     * @param {Body} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailPost(
      body: Body,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body> {
      const localVarFetchArgs = EmailEmailApiFetchParamCreator(
        configuration
      ).emailPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get the email settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailSettingsGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body1> {
      const localVarFetchArgs =
        EmailEmailApiFetchParamCreator(configuration).emailSettingsGet(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Send an test email
     * @param {Body1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTestPost(
      body: Body1,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body1> {
      const localVarFetchArgs = EmailEmailApiFetchParamCreator(
        configuration
      ).emailTestPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * EmailEmailApi - factory interface
 * @export
 */
export const EmailEmailApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Send an email
     * @param {Body} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailPost(body: Body, options?: any) {
      return EmailEmailApiFp(configuration).emailPost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * Get the email settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailSettingsGet(options?: any) {
      return EmailEmailApiFp(configuration).emailSettingsGet(options)(
        fetch,
        basePath
      );
    },
    /**
     * Send an test email
     * @param {Body1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTestPost(body: Body1, options?: any) {
      return EmailEmailApiFp(configuration).emailTestPost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * EmailEmailApi - object-oriented interface
 * @export
 * @class EmailEmailApi
 * @extends {BaseAPI}
 */
export class EmailEmailApi extends BaseAPI {
  /**
   * Send an email
   * @param {Body} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailEmailApi
   */
  public emailPost(body: Body, options?: any) {
    return EmailEmailApiFp(this.configuration).emailPost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Get the email settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailEmailApi
   */
  public emailSettingsGet(options?: any) {
    return EmailEmailApiFp(this.configuration).emailSettingsGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Send an test email
   * @param {Body1} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailEmailApi
   */
  public emailTestPost(body: Body1, options?: any) {
    return EmailEmailApiFp(this.configuration).emailTestPost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * PostsApi - fetch parameter creator
 * @export
 */
export const PostsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve the number of posts documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsCountGet(options: any = {}): FetchArgs {
      const localVarPath = `/posts/count`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find all the posts's records
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/posts`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (limit !== undefined) {
        localVarQueryParameter['_limit'] = limit;
      }

      if (sort !== undefined) {
        localVarQueryParameter['_sort'] = sort;
      }

      if (start !== undefined) {
        localVarQueryParameter['_start'] = start;
      }

      if (eq !== undefined) {
        localVarQueryParameter['_eq'] = eq;
      }

      if (ne !== undefined) {
        localVarQueryParameter['_ne'] = ne;
      }

      if (lt !== undefined) {
        localVarQueryParameter['_lt'] = lt;
      }

      if (lte !== undefined) {
        localVarQueryParameter['_lte'] = lte;
      }

      if (gt !== undefined) {
        localVarQueryParameter['_gt'] = gt;
      }

      if (gte !== undefined) {
        localVarQueryParameter['_gte'] = gte;
      }

      if (contains !== undefined) {
        localVarQueryParameter['_contains'] = contains;
      }

      if (containss !== undefined) {
        localVarQueryParameter['_containss'] = containss;
      }

      if (_in) {
        localVarQueryParameter['_in'] = _in;
      }

      if (nin) {
        localVarQueryParameter['_nin'] = nin;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a single posts record
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdDelete(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postsIdDelete.'
        );
      }
      const localVarPath = `/posts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find one posts record
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdGet(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postsIdGet.'
        );
      }
      const localVarPath = `/posts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a single posts record
     * @param {NewPosts} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdPut(body: NewPosts, id: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling postsIdPut.'
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postsIdPut.'
        );
      }
      const localVarPath = `/posts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'NewPosts' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new posts record
     * @param {NewPosts} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPost(body: NewPosts, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling postsPost.'
        );
      }
      const localVarPath = `/posts`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'NewPosts' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve the number of posts documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsCountGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs =
        PostsApiFetchParamCreator(configuration).postsCountGet(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Find all the posts's records
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Posts>> {
      const localVarFetchArgs = PostsApiFetchParamCreator(
        configuration
      ).postsGet(
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a single posts record
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdDelete(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = PostsApiFetchParamCreator(
        configuration
      ).postsIdDelete(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Find one posts record
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdGet(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Posts> {
      const localVarFetchArgs = PostsApiFetchParamCreator(
        configuration
      ).postsIdGet(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update a single posts record
     * @param {NewPosts} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdPut(
      body: NewPosts,
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Posts> {
      const localVarFetchArgs = PostsApiFetchParamCreator(
        configuration
      ).postsIdPut(body, id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new posts record
     * @param {NewPosts} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPost(
      body: NewPosts,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Posts> {
      const localVarFetchArgs = PostsApiFetchParamCreator(
        configuration
      ).postsPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Retrieve the number of posts documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsCountGet(options?: any) {
      return PostsApiFp(configuration).postsCountGet(options)(fetch, basePath);
    },
    /**
     * Find all the posts's records
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ) {
      return PostsApiFp(configuration).postsGet(
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      )(fetch, basePath);
    },
    /**
     * Delete a single posts record
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdDelete(id: string, options?: any) {
      return PostsApiFp(configuration).postsIdDelete(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Find one posts record
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdGet(id: string, options?: any) {
      return PostsApiFp(configuration).postsIdGet(id, options)(fetch, basePath);
    },
    /**
     * Update a single posts record
     * @param {NewPosts} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdPut(body: NewPosts, id: string, options?: any) {
      return PostsApiFp(configuration).postsIdPut(
        body,
        id,
        options
      )(fetch, basePath);
    },
    /**
     * Create a new posts record
     * @param {NewPosts} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPost(body: NewPosts, options?: any) {
      return PostsApiFp(configuration).postsPost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
  /**
   * Retrieve the number of posts documents
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsCountGet(options?: any) {
    return PostsApiFp(this.configuration).postsCountGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Find all the posts's records
   * @param {number} [limit] Maximum number of results possible
   * @param {string} [sort] Sort according to a specific field.
   * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
   * @param {string} [eq] Get entries that matches exactly your input
   * @param {string} [ne] Get records that are not equals to something
   * @param {string} [lt] Get record that are lower than a value
   * @param {string} [lte] Get records that are lower than or equal to a value
   * @param {string} [gt] Get records that are greater than a value
   * @param {string} [gte] Get records that are greater than  or equal a value
   * @param {string} [contains] Get records that contains a value
   * @param {string} [containss] Get records that contains (case sensitive) a value
   * @param {Array<string>} [_in] Get records that matches any value in the array of values
   * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsGet(
    limit?: number,
    sort?: string,
    start?: number,
    eq?: string,
    ne?: string,
    lt?: string,
    lte?: string,
    gt?: string,
    gte?: string,
    contains?: string,
    containss?: string,
    _in?: Array<string>,
    nin?: Array<string>,
    options?: any
  ) {
    return PostsApiFp(this.configuration).postsGet(
      limit,
      sort,
      start,
      eq,
      ne,
      lt,
      lte,
      gt,
      gte,
      contains,
      containss,
      _in,
      nin,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Delete a single posts record
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsIdDelete(id: string, options?: any) {
    return PostsApiFp(this.configuration).postsIdDelete(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Find one posts record
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsIdGet(id: string, options?: any) {
    return PostsApiFp(this.configuration).postsIdGet(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Update a single posts record
   * @param {NewPosts} body
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsIdPut(body: NewPosts, id: string, options?: any) {
    return PostsApiFp(this.configuration).postsIdPut(
      body,
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new posts record
   * @param {NewPosts} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsPost(body: NewPosts, options?: any) {
    return PostsApiFp(this.configuration).postsPost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * UploadFileApi - fetch parameter creator
 * @export
 */
export const UploadFileApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve the total number of uploaded files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesCountGet(options: any = {}): FetchArgs {
      const localVarPath = `/upload/files/count`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all file documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesGet(options: any = {}): FetchArgs {
      const localVarPath = `/upload/files`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an uploaded file
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesIdDelete(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling uploadFilesIdDelete.'
        );
      }
      const localVarPath = `/upload/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a single file depending on its id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesIdGet(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling uploadFilesIdGet.'
        );
      }
      const localVarPath = `/upload/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upload a file
     * @param {Body2} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPost(body: Body2, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling uploadPost.'
        );
      }
      const localVarPath = `/upload/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body2' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search for an uploaded file
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSearchIdGet(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling uploadSearchIdGet.'
        );
      }
      const localVarPath = `/upload/search/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UploadFileApi - functional programming interface
 * @export
 */
export const UploadFileApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve the total number of uploaded files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesCountGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs =
        UploadFileApiFetchParamCreator(configuration).uploadFilesCountGet(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all file documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs =
        UploadFileApiFetchParamCreator(configuration).uploadFilesGet(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete an uploaded file
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesIdDelete(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs = UploadFileApiFetchParamCreator(
        configuration
      ).uploadFilesIdDelete(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve a single file depending on its id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesIdGet(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs = UploadFileApiFetchParamCreator(
        configuration
      ).uploadFilesIdGet(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Upload a file
     * @param {Body2} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPost(
      body: Body2,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs = UploadFileApiFetchParamCreator(
        configuration
      ).uploadPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Search for an uploaded file
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSearchIdGet(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs = UploadFileApiFetchParamCreator(
        configuration
      ).uploadSearchIdGet(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UploadFileApi - factory interface
 * @export
 */
export const UploadFileApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Retrieve the total number of uploaded files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesCountGet(options?: any) {
      return UploadFileApiFp(configuration).uploadFilesCountGet(options)(
        fetch,
        basePath
      );
    },
    /**
     * Retrieve all file documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesGet(options?: any) {
      return UploadFileApiFp(configuration).uploadFilesGet(options)(
        fetch,
        basePath
      );
    },
    /**
     * Delete an uploaded file
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesIdDelete(id: string, options?: any) {
      return UploadFileApiFp(configuration).uploadFilesIdDelete(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Retrieve a single file depending on its id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilesIdGet(id: string, options?: any) {
      return UploadFileApiFp(configuration).uploadFilesIdGet(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Upload a file
     * @param {Body2} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPost(body: Body2, options?: any) {
      return UploadFileApiFp(configuration).uploadPost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * Search for an uploaded file
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSearchIdGet(id: string, options?: any) {
      return UploadFileApiFp(configuration).uploadSearchIdGet(id, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * UploadFileApi - object-oriented interface
 * @export
 * @class UploadFileApi
 * @extends {BaseAPI}
 */
export class UploadFileApi extends BaseAPI {
  /**
   * Retrieve the total number of uploaded files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadFileApi
   */
  public uploadFilesCountGet(options?: any) {
    return UploadFileApiFp(this.configuration).uploadFilesCountGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Retrieve all file documents
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadFileApi
   */
  public uploadFilesGet(options?: any) {
    return UploadFileApiFp(this.configuration).uploadFilesGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Delete an uploaded file
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadFileApi
   */
  public uploadFilesIdDelete(id: string, options?: any) {
    return UploadFileApiFp(this.configuration).uploadFilesIdDelete(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Retrieve a single file depending on its id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadFileApi
   */
  public uploadFilesIdGet(id: string, options?: any) {
    return UploadFileApiFp(this.configuration).uploadFilesIdGet(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Upload a file
   * @param {Body2} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadFileApi
   */
  public uploadPost(body: Body2, options?: any) {
    return UploadFileApiFp(this.configuration).uploadPost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Search for an uploaded file
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadFileApi
   */
  public uploadSearchIdGet(id: string, options?: any) {
    return UploadFileApiFp(this.configuration).uploadSearchIdGet(id, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * UsersPermissionsRoleApi - fetch parameter creator
 * @export
 */
export const UsersPermissionsRoleApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve all role documents
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/users-permissions/roles`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (limit !== undefined) {
        localVarQueryParameter['_limit'] = limit;
      }

      if (sort !== undefined) {
        localVarQueryParameter['_sort'] = sort;
      }

      if (start !== undefined) {
        localVarQueryParameter['_start'] = start;
      }

      if (eq !== undefined) {
        localVarQueryParameter['_eq'] = eq;
      }

      if (ne !== undefined) {
        localVarQueryParameter['_ne'] = ne;
      }

      if (lt !== undefined) {
        localVarQueryParameter['_lt'] = lt;
      }

      if (lte !== undefined) {
        localVarQueryParameter['_lte'] = lte;
      }

      if (gt !== undefined) {
        localVarQueryParameter['_gt'] = gt;
      }

      if (gte !== undefined) {
        localVarQueryParameter['_gte'] = gte;
      }

      if (contains !== undefined) {
        localVarQueryParameter['_contains'] = contains;
      }

      if (containss !== undefined) {
        localVarQueryParameter['_containss'] = containss;
      }

      if (_in) {
        localVarQueryParameter['_in'] = _in;
      }

      if (nin) {
        localVarQueryParameter['_nin'] = nin;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a role depending on its id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesIdGet(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersPermissionsRolesIdGet.'
        );
      }
      const localVarPath = `/users-permissions/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new role
     * @param {NewUsersPermissionsRole} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesPost(
      body: NewUsersPermissionsRole,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling usersPermissionsRolesPost.'
        );
      }
      const localVarPath = `/users-permissions/roles`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'NewUsersPermissionsRole' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesRoleDelete(
      role: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'role' is not null or undefined
      if (role === null || role === undefined) {
        throw new RequiredError(
          'role',
          'Required parameter role was null or undefined when calling usersPermissionsRolesRoleDelete.'
        );
      }
      const localVarPath = `/users-permissions/roles/{role}`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a role
     * @param {NewUsersPermissionsRole} body
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesRolePut(
      body: NewUsersPermissionsRole,
      role: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling usersPermissionsRolesRolePut.'
        );
      }
      // verify required parameter 'role' is not null or undefined
      if (role === null || role === undefined) {
        throw new RequiredError(
          'role',
          'Required parameter role was null or undefined when calling usersPermissionsRolesRolePut.'
        );
      }
      const localVarPath = `/users-permissions/roles/{role}`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'NewUsersPermissionsRole' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersPermissionsRoleApi - functional programming interface
 * @export
 */
export const UsersPermissionsRoleApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve all role documents
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<UsersPermissionsRole>> {
      const localVarFetchArgs = UsersPermissionsRoleApiFetchParamCreator(
        configuration
      ).usersPermissionsRolesGet(
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve a role depending on its id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesIdGet(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsRole> {
      const localVarFetchArgs = UsersPermissionsRoleApiFetchParamCreator(
        configuration
      ).usersPermissionsRolesIdGet(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new role
     * @param {NewUsersPermissionsRole} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesPost(
      body: NewUsersPermissionsRole,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsRole> {
      const localVarFetchArgs = UsersPermissionsRoleApiFetchParamCreator(
        configuration
      ).usersPermissionsRolesPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesRoleDelete(
      role: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs = UsersPermissionsRoleApiFetchParamCreator(
        configuration
      ).usersPermissionsRolesRoleDelete(role, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update a role
     * @param {NewUsersPermissionsRole} body
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesRolePut(
      body: NewUsersPermissionsRole,
      role: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsRole> {
      const localVarFetchArgs = UsersPermissionsRoleApiFetchParamCreator(
        configuration
      ).usersPermissionsRolesRolePut(body, role, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UsersPermissionsRoleApi - factory interface
 * @export
 */
export const UsersPermissionsRoleApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Retrieve all role documents
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ) {
      return UsersPermissionsRoleApiFp(configuration).usersPermissionsRolesGet(
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      )(fetch, basePath);
    },
    /**
     * Retrieve a role depending on its id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesIdGet(id: string, options?: any) {
      return UsersPermissionsRoleApiFp(
        configuration
      ).usersPermissionsRolesIdGet(id, options)(fetch, basePath);
    },
    /**
     * Create a new role
     * @param {NewUsersPermissionsRole} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesPost(body: NewUsersPermissionsRole, options?: any) {
      return UsersPermissionsRoleApiFp(configuration).usersPermissionsRolesPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * Delete a role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesRoleDelete(role: string, options?: any) {
      return UsersPermissionsRoleApiFp(
        configuration
      ).usersPermissionsRolesRoleDelete(role, options)(fetch, basePath);
    },
    /**
     * Update a role
     * @param {NewUsersPermissionsRole} body
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsRolesRolePut(
      body: NewUsersPermissionsRole,
      role: string,
      options?: any
    ) {
      return UsersPermissionsRoleApiFp(
        configuration
      ).usersPermissionsRolesRolePut(
        body,
        role,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * UsersPermissionsRoleApi - object-oriented interface
 * @export
 * @class UsersPermissionsRoleApi
 * @extends {BaseAPI}
 */
export class UsersPermissionsRoleApi extends BaseAPI {
  /**
   * Retrieve all role documents
   * @param {number} [limit] Maximum number of results possible
   * @param {string} [sort] Sort according to a specific field.
   * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
   * @param {string} [eq] Get entries that matches exactly your input
   * @param {string} [ne] Get records that are not equals to something
   * @param {string} [lt] Get record that are lower than a value
   * @param {string} [lte] Get records that are lower than or equal to a value
   * @param {string} [gt] Get records that are greater than a value
   * @param {string} [gte] Get records that are greater than  or equal a value
   * @param {string} [contains] Get records that contains a value
   * @param {string} [containss] Get records that contains (case sensitive) a value
   * @param {Array<string>} [_in] Get records that matches any value in the array of values
   * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsRoleApi
   */
  public usersPermissionsRolesGet(
    limit?: number,
    sort?: string,
    start?: number,
    eq?: string,
    ne?: string,
    lt?: string,
    lte?: string,
    gt?: string,
    gte?: string,
    contains?: string,
    containss?: string,
    _in?: Array<string>,
    nin?: Array<string>,
    options?: any
  ) {
    return UsersPermissionsRoleApiFp(
      this.configuration
    ).usersPermissionsRolesGet(
      limit,
      sort,
      start,
      eq,
      ne,
      lt,
      lte,
      gt,
      gte,
      contains,
      containss,
      _in,
      nin,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve a role depending on its id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsRoleApi
   */
  public usersPermissionsRolesIdGet(id: string, options?: any) {
    return UsersPermissionsRoleApiFp(
      this.configuration
    ).usersPermissionsRolesIdGet(id, options)(this.fetch, this.basePath);
  }

  /**
   * Create a new role
   * @param {NewUsersPermissionsRole} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsRoleApi
   */
  public usersPermissionsRolesPost(
    body: NewUsersPermissionsRole,
    options?: any
  ) {
    return UsersPermissionsRoleApiFp(
      this.configuration
    ).usersPermissionsRolesPost(body, options)(this.fetch, this.basePath);
  }

  /**
   * Delete a role
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsRoleApi
   */
  public usersPermissionsRolesRoleDelete(role: string, options?: any) {
    return UsersPermissionsRoleApiFp(
      this.configuration
    ).usersPermissionsRolesRoleDelete(role, options)(this.fetch, this.basePath);
  }

  /**
   * Update a role
   * @param {NewUsersPermissionsRole} body
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsRoleApi
   */
  public usersPermissionsRolesRolePut(
    body: NewUsersPermissionsRole,
    role: string,
    options?: any
  ) {
    return UsersPermissionsRoleApiFp(
      this.configuration
    ).usersPermissionsRolesRolePut(
      body,
      role,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * UsersPermissionsUserApi - fetch parameter creator
 * @export
 */
export const UsersPermissionsUserApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Validate a user account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authEmailConfirmationGet(options: any = {}): FetchArgs {
      const localVarPath = `/auth/email-confirmation`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send the reset password email link
     * @param {Body4} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authForgotPasswordPost(body: Body4, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authForgotPasswordPost.'
        );
      }
      const localVarPath = `/auth/forgot-password`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body4' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Login a user using the identifiers email and password
     * @param {Body3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLocalPost(body: Body3, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authLocalPost.'
        );
      }
      const localVarPath = `/auth/local`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body3' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Register a new user with the default role
     * @param {NewUsersPermissionsUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLocalRegisterPost(
      body: NewUsersPermissionsUser,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authLocalRegisterPost.'
        );
      }
      const localVarPath = `/auth/local/register`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'NewUsersPermissionsUser' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Successfull redirection after approving a provider
     * @param {string} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authProviderCallbackGet(provider: string, options: any = {}): FetchArgs {
      // verify required parameter 'provider' is not null or undefined
      if (provider === null || provider === undefined) {
        throw new RequiredError(
          'provider',
          'Required parameter provider was null or undefined when calling authProviderCallbackGet.'
        );
      }
      const localVarPath = `/auth/{provider}/callback`.replace(
        `{${'provider'}}`,
        encodeURIComponent(String(provider))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reset user password with a code (resetToken)
     * @param {Body5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authResetPasswordPost(body: Body5, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authResetPasswordPost.'
        );
      }
      const localVarPath = `/auth/reset-password`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body5' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send a confirmation email to user
     * @param {Body6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSendEmailConfirmationPost(body: Body6, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authSendEmailConfirmationPost.'
        );
      }
      const localVarPath = `/auth/send-email-confirmation`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'Body6' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Connect a provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectGet(options: any = {}): FetchArgs {
      const localVarPath = `/connect/*`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all user documents
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (limit !== undefined) {
        localVarQueryParameter['_limit'] = limit;
      }

      if (sort !== undefined) {
        localVarQueryParameter['_sort'] = sort;
      }

      if (start !== undefined) {
        localVarQueryParameter['_start'] = start;
      }

      if (eq !== undefined) {
        localVarQueryParameter['_eq'] = eq;
      }

      if (ne !== undefined) {
        localVarQueryParameter['_ne'] = ne;
      }

      if (lt !== undefined) {
        localVarQueryParameter['_lt'] = lt;
      }

      if (lte !== undefined) {
        localVarQueryParameter['_lte'] = lte;
      }

      if (gt !== undefined) {
        localVarQueryParameter['_gt'] = gt;
      }

      if (gte !== undefined) {
        localVarQueryParameter['_gte'] = gte;
      }

      if (contains !== undefined) {
        localVarQueryParameter['_contains'] = contains;
      }

      if (containss !== undefined) {
        localVarQueryParameter['_containss'] = containss;
      }

      if (_in) {
        localVarQueryParameter['_in'] = _in;
      }

      if (nin) {
        localVarQueryParameter['_nin'] = nin;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an existing user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdDelete(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdDelete.'
        );
      }
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a single user depending on his id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdGet(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdGet.'
        );
      }
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an existing user
     * @param {NewUsersPermissionsUser} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdPut(
      body: NewUsersPermissionsUser,
      id: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling usersIdPut.'
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdPut.'
        );
      }
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'NewUsersPermissionsUser' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve the logged in user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeGet(options: any = {}): FetchArgs {
      const localVarPath = `/users/me`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search for users
     * @param {string} id
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsSearchIdGet(
      id: string,
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersPermissionsSearchIdGet.'
        );
      }
      const localVarPath = `/users-permissions/search/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (limit !== undefined) {
        localVarQueryParameter['_limit'] = limit;
      }

      if (sort !== undefined) {
        localVarQueryParameter['_sort'] = sort;
      }

      if (start !== undefined) {
        localVarQueryParameter['_start'] = start;
      }

      if (eq !== undefined) {
        localVarQueryParameter['_eq'] = eq;
      }

      if (ne !== undefined) {
        localVarQueryParameter['_ne'] = ne;
      }

      if (lt !== undefined) {
        localVarQueryParameter['_lt'] = lt;
      }

      if (lte !== undefined) {
        localVarQueryParameter['_lte'] = lte;
      }

      if (gt !== undefined) {
        localVarQueryParameter['_gt'] = gt;
      }

      if (gte !== undefined) {
        localVarQueryParameter['_gte'] = gte;
      }

      if (contains !== undefined) {
        localVarQueryParameter['_contains'] = contains;
      }

      if (containss !== undefined) {
        localVarQueryParameter['_containss'] = containss;
      }

      if (_in) {
        localVarQueryParameter['_in'] = _in;
      }

      if (nin) {
        localVarQueryParameter['_nin'] = nin;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersPermissionsUserApi - functional programming interface
 * @export
 */
export const UsersPermissionsUserApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     * Validate a user account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authEmailConfirmationGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body5> {
      const localVarFetchArgs =
        UsersPermissionsUserApiFetchParamCreator(
          configuration
        ).authEmailConfirmationGet(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Send the reset password email link
     * @param {Body4} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authForgotPasswordPost(
      body: Body4,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body4> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).authForgotPasswordPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Login a user using the identifiers email and password
     * @param {Body3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLocalPost(
      body: Body3,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body3> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).authLocalPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Register a new user with the default role
     * @param {NewUsersPermissionsUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLocalRegisterPost(
      body: NewUsersPermissionsUser,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsUser> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).authLocalRegisterPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Successfull redirection after approving a provider
     * @param {string} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authProviderCallbackGet(
      provider: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body3> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).authProviderCallbackGet(provider, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Reset user password with a code (resetToken)
     * @param {Body5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authResetPasswordPost(
      body: Body5,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body5> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).authResetPasswordPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Send a confirmation email to user
     * @param {Body6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSendEmailConfirmationPost(
      body: Body6,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body6> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).authSendEmailConfirmationPost(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Connect a provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body2> {
      const localVarFetchArgs =
        UsersPermissionsUserApiFetchParamCreator(configuration).connectGet(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all user documents
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<UsersPermissionsUser>> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).usersGet(
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete an existing user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdDelete(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Body6> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).usersIdDelete(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve a single user depending on his id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdGet(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsUser> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).usersIdGet(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update an existing user
     * @param {NewUsersPermissionsUser} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdPut(
      body: NewUsersPermissionsUser,
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsUser> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).usersIdPut(body, id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve the logged in user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UsersPermissionsUser> {
      const localVarFetchArgs =
        UsersPermissionsUserApiFetchParamCreator(configuration).usersMeGet(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Search for users
     * @param {string} id
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsSearchIdGet(
      id: string,
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<UsersPermissionsUser>> {
      const localVarFetchArgs = UsersPermissionsUserApiFetchParamCreator(
        configuration
      ).usersPermissionsSearchIdGet(
        id,
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UsersPermissionsUserApi - factory interface
 * @export
 */
export const UsersPermissionsUserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Validate a user account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authEmailConfirmationGet(options?: any) {
      return UsersPermissionsUserApiFp(configuration).authEmailConfirmationGet(
        options
      )(fetch, basePath);
    },
    /**
     * Send the reset password email link
     * @param {Body4} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authForgotPasswordPost(body: Body4, options?: any) {
      return UsersPermissionsUserApiFp(configuration).authForgotPasswordPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * Login a user using the identifiers email and password
     * @param {Body3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLocalPost(body: Body3, options?: any) {
      return UsersPermissionsUserApiFp(configuration).authLocalPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * Register a new user with the default role
     * @param {NewUsersPermissionsUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLocalRegisterPost(body: NewUsersPermissionsUser, options?: any) {
      return UsersPermissionsUserApiFp(configuration).authLocalRegisterPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * Successfull redirection after approving a provider
     * @param {string} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authProviderCallbackGet(provider: string, options?: any) {
      return UsersPermissionsUserApiFp(configuration).authProviderCallbackGet(
        provider,
        options
      )(fetch, basePath);
    },
    /**
     * Reset user password with a code (resetToken)
     * @param {Body5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authResetPasswordPost(body: Body5, options?: any) {
      return UsersPermissionsUserApiFp(configuration).authResetPasswordPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * Send a confirmation email to user
     * @param {Body6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSendEmailConfirmationPost(body: Body6, options?: any) {
      return UsersPermissionsUserApiFp(
        configuration
      ).authSendEmailConfirmationPost(body, options)(fetch, basePath);
    },
    /**
     * Connect a provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectGet(options?: any) {
      return UsersPermissionsUserApiFp(configuration).connectGet(options)(
        fetch,
        basePath
      );
    },
    /**
     * Retrieve all user documents
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ) {
      return UsersPermissionsUserApiFp(configuration).usersGet(
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      )(fetch, basePath);
    },
    /**
     * Delete an existing user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdDelete(id: string, options?: any) {
      return UsersPermissionsUserApiFp(configuration).usersIdDelete(
        id,
        options
      )(fetch, basePath);
    },
    /**
     * Retrieve a single user depending on his id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdGet(id: string, options?: any) {
      return UsersPermissionsUserApiFp(configuration).usersIdGet(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Update an existing user
     * @param {NewUsersPermissionsUser} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdPut(body: NewUsersPermissionsUser, id: string, options?: any) {
      return UsersPermissionsUserApiFp(configuration).usersIdPut(
        body,
        id,
        options
      )(fetch, basePath);
    },
    /**
     * Retrieve the logged in user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeGet(options?: any) {
      return UsersPermissionsUserApiFp(configuration).usersMeGet(options)(
        fetch,
        basePath
      );
    },
    /**
     * Search for users
     * @param {string} id
     * @param {number} [limit] Maximum number of results possible
     * @param {string} [sort] Sort according to a specific field.
     * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
     * @param {string} [eq] Get entries that matches exactly your input
     * @param {string} [ne] Get records that are not equals to something
     * @param {string} [lt] Get record that are lower than a value
     * @param {string} [lte] Get records that are lower than or equal to a value
     * @param {string} [gt] Get records that are greater than a value
     * @param {string} [gte] Get records that are greater than  or equal a value
     * @param {string} [contains] Get records that contains a value
     * @param {string} [containss] Get records that contains (case sensitive) a value
     * @param {Array<string>} [_in] Get records that matches any value in the array of values
     * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPermissionsSearchIdGet(
      id: string,
      limit?: number,
      sort?: string,
      start?: number,
      eq?: string,
      ne?: string,
      lt?: string,
      lte?: string,
      gt?: string,
      gte?: string,
      contains?: string,
      containss?: string,
      _in?: Array<string>,
      nin?: Array<string>,
      options?: any
    ) {
      return UsersPermissionsUserApiFp(
        configuration
      ).usersPermissionsSearchIdGet(
        id,
        limit,
        sort,
        start,
        eq,
        ne,
        lt,
        lte,
        gt,
        gte,
        contains,
        containss,
        _in,
        nin,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * UsersPermissionsUserApi - object-oriented interface
 * @export
 * @class UsersPermissionsUserApi
 * @extends {BaseAPI}
 */
export class UsersPermissionsUserApi extends BaseAPI {
  /**
   * Validate a user account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authEmailConfirmationGet(options?: any) {
    return UsersPermissionsUserApiFp(
      this.configuration
    ).authEmailConfirmationGet(options)(this.fetch, this.basePath);
  }

  /**
   * Send the reset password email link
   * @param {Body4} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authForgotPasswordPost(body: Body4, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).authForgotPasswordPost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Login a user using the identifiers email and password
   * @param {Body3} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authLocalPost(body: Body3, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).authLocalPost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Register a new user with the default role
   * @param {NewUsersPermissionsUser} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authLocalRegisterPost(body: NewUsersPermissionsUser, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).authLocalRegisterPost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Successfull redirection after approving a provider
   * @param {string} provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authProviderCallbackGet(provider: string, options?: any) {
    return UsersPermissionsUserApiFp(
      this.configuration
    ).authProviderCallbackGet(provider, options)(this.fetch, this.basePath);
  }

  /**
   * Reset user password with a code (resetToken)
   * @param {Body5} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authResetPasswordPost(body: Body5, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).authResetPasswordPost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Send a confirmation email to user
   * @param {Body6} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public authSendEmailConfirmationPost(body: Body6, options?: any) {
    return UsersPermissionsUserApiFp(
      this.configuration
    ).authSendEmailConfirmationPost(body, options)(this.fetch, this.basePath);
  }

  /**
   * Connect a provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public connectGet(options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).connectGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Retrieve all user documents
   * @param {number} [limit] Maximum number of results possible
   * @param {string} [sort] Sort according to a specific field.
   * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
   * @param {string} [eq] Get entries that matches exactly your input
   * @param {string} [ne] Get records that are not equals to something
   * @param {string} [lt] Get record that are lower than a value
   * @param {string} [lte] Get records that are lower than or equal to a value
   * @param {string} [gt] Get records that are greater than a value
   * @param {string} [gte] Get records that are greater than  or equal a value
   * @param {string} [contains] Get records that contains a value
   * @param {string} [containss] Get records that contains (case sensitive) a value
   * @param {Array<string>} [_in] Get records that matches any value in the array of values
   * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public usersGet(
    limit?: number,
    sort?: string,
    start?: number,
    eq?: string,
    ne?: string,
    lt?: string,
    lte?: string,
    gt?: string,
    gte?: string,
    contains?: string,
    containss?: string,
    _in?: Array<string>,
    nin?: Array<string>,
    options?: any
  ) {
    return UsersPermissionsUserApiFp(this.configuration).usersGet(
      limit,
      sort,
      start,
      eq,
      ne,
      lt,
      lte,
      gt,
      gte,
      contains,
      containss,
      _in,
      nin,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Delete an existing user
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public usersIdDelete(id: string, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).usersIdDelete(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve a single user depending on his id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public usersIdGet(id: string, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).usersIdGet(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Update an existing user
   * @param {NewUsersPermissionsUser} body
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public usersIdPut(body: NewUsersPermissionsUser, id: string, options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).usersIdPut(
      body,
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve the logged in user information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public usersMeGet(options?: any) {
    return UsersPermissionsUserApiFp(this.configuration).usersMeGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Search for users
   * @param {string} id
   * @param {number} [limit] Maximum number of results possible
   * @param {string} [sort] Sort according to a specific field.
   * @param {number} [start] Skip a specific number of entries (especially useful for pagination)
   * @param {string} [eq] Get entries that matches exactly your input
   * @param {string} [ne] Get records that are not equals to something
   * @param {string} [lt] Get record that are lower than a value
   * @param {string} [lte] Get records that are lower than or equal to a value
   * @param {string} [gt] Get records that are greater than a value
   * @param {string} [gte] Get records that are greater than  or equal a value
   * @param {string} [contains] Get records that contains a value
   * @param {string} [containss] Get records that contains (case sensitive) a value
   * @param {Array<string>} [_in] Get records that matches any value in the array of values
   * @param {Array<string>} [nin] Get records that doesn&#x27;t match any value in the array of values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersPermissionsUserApi
   */
  public usersPermissionsSearchIdGet(
    id: string,
    limit?: number,
    sort?: string,
    start?: number,
    eq?: string,
    ne?: string,
    lt?: string,
    lte?: string,
    gt?: string,
    gte?: string,
    contains?: string,
    containss?: string,
    _in?: Array<string>,
    nin?: Array<string>,
    options?: any
  ) {
    return UsersPermissionsUserApiFp(
      this.configuration
    ).usersPermissionsSearchIdGet(
      id,
      limit,
      sort,
      start,
      eq,
      ne,
      lt,
      lte,
      gt,
      gte,
      contains,
      containss,
      _in,
      nin,
      options
    )(this.fetch, this.basePath);
  }
}
